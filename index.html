<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mines Predictor - Premium Access</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&amp;family=Orbitron:wght@400;700;900&amp;display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    
    <style>
        /* === CYBERPUNK THEME === */
        :root {
            --bg-color: #0a0e17;
            --glass: rgba(15, 22, 39, 0.9);
            --glass-border: rgba(0, 247, 255, 0.2);
            --neon-blue: #00f7ff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff9d;
            --neon-red: #ff0055;
            --neon-yellow: #ffcc00;
            --text: #ffffff;
            --text-muted: #8a9bbd;
            --radius: 16px;
            --font-main: 'Poppins', sans-serif;
            --font-cyber: 'Orbitron', monospace;
            --safe-green: #00ff88;
            --danger-red: #ff3355;
            --warning-orange: #ff9900;
            --selection-yellow: #ffff00;
        }

        /* EXISTING CSS STYLES REMAIN THE SAME UNTIL... */
        
        /* === FLOATING WHATSAPP ICONS === */
        .floating-icons {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 15px;
            transition: all 0.3s ease;
        }

        .floating-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #25D366, #128C7E);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 28px;
            box-shadow: 0 5px 20px rgba(37, 211, 102, 0.4);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            animation: float 3s ease-in-out infinite;
            border: 2px solid white;
            position: relative;
        }

        .floating-icon.channel {
            background: linear-gradient(135deg, #667eea, #764ba2);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .floating-icon.support {
            background: linear-gradient(135deg, #667eea, #764ba2);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .floating-icon:hover {
            transform: scale(1.1) translateY(-5px);
            box-shadow: 0 10px 30px rgba(37, 211, 102, 0.6);
        }

        .floating-icon.channel:hover {
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.6);
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .icon-tooltip {
            position: absolute;
            right: 70px;
            background: rgba(15, 22, 39, 0.95);
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid var(--neon-blue);
            color: white;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .floating-icon:hover .icon-tooltip {
            opacity: 1;
        }

        /* === PREMIUM WALL SCREEN === */
        .premium-wall {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-color);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow-y: auto;
        }

        .premium-container {
            background: rgba(15, 22, 39, 0.95);
            border: 1px solid var(--neon-blue);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 100%;
            box-shadow: 0 0 50px rgba(0, 247, 255, 0.3);
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .premium-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .premium-header h2 {
            font-family: var(--font-cyber);
            background: linear-gradient(45deg, var(--neon-blue), var(--neon-pink));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-size: 2rem;
            margin: 0;
        }

        .premium-header p {
            color: var(--text-muted);
            margin-top: 10px;
        }

        .premium-options {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 30px;
        }

        .premium-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius);
            padding: 20px;
            transition: all 0.3s;
        }

        .premium-card:hover {
            border-color: var(--neon-blue);
            transform: translateY(-5px);
        }

        .premium-card h3 {
            color: var(--neon-green);
            font-family: var(--font-cyber);
            margin: 0 0 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .premium-price {
            font-size: 2rem;
            color: var(--neon-yellow);
            font-weight: 700;
            margin: 10px 0;
        }

        .premium-features {
            list-style: none;
            padding: 0;
            margin: 15px 0;
        }

        .premium-features li {
            margin: 8px 0;
            color: var(--text);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .premium-features li i {
            color: var(--neon-green);
        }

        /* === PREMIUM CODE INPUT === */
        .code-input-container {
            margin-top: 20px;
        }

        .code-input {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .code-input input {
            flex: 1;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--neon-blue);
            border-radius: 10px;
            color: white;
            font-family: var(--font-cyber);
            text-align: center;
            font-size: 1.2rem;
            letter-spacing: 2px;
        }

        .code-input input::placeholder {
            color: var(--text-muted);
            letter-spacing: normal;
        }

        .validate-btn {
            padding: 15px 25px;
            background: linear-gradient(135deg, var(--neon-blue), #0066ff);
            border: none;
            border-radius: 10px;
            color: #000;
            font-family: var(--font-cyber);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }

        .validate-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0, 247, 255, 0.4);
        }

        /* === ERROR MESSAGES === */
        .error-message {
            background: rgba(255, 0, 85, 0.1);
            border: 1px solid var(--neon-red);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            color: var(--neon-red);
            text-align: center;
            animation: errorPulse 2s infinite;
        }

        @keyframes errorPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 0, 85, 0.2); }
            50% { box-shadow: 0 0 20px rgba(255, 0, 85, 0.4); }
        }

        .success-message {
            background: rgba(0, 255, 157, 0.1);
            border: 1px solid var(--neon-green);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            color: var(--neon-green);
            text-align: center;
        }

        /* === PAYMENT SECTION === */
        .payment-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--glass-border);
        }

        .payment-phone-input {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }

        .payment-phone-input input {
            flex: 1;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--neon-blue);
            border-radius: 10px;
            color: white;
            font-family: var(--font-cyber);
        }

        .pay-btn {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, var(--neon-green), #00a86b);
            border: none;
            border-radius: 10px;
            color: #000;
            font-family: var(--font-cyber);
            font-weight: 700;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .pay-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 255, 157, 0.4);
        }

        /* === PREMIUM STATUS BAR === */
        .premium-status-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, var(--neon-green), var(--neon-blue));
            padding: 10px;
            text-align: center;
            font-family: var(--font-cyber);
            font-weight: 700;
            z-index: 999;
            color: #000;
            animation: statusPulse 3s infinite;
        }

        @keyframes statusPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.9; }
        }

        /* === RESPONSIVE === */
        @media (max-width: 768px) {
            .floating-icons {
                bottom: 10px;
                right: 10px;
            }
            
            .floating-icon {
                width: 50px;
                height: 50px;
                font-size: 24px;
            }
            
            .premium-container {
                padding: 20px;
                margin: 10px;
            }
        }

        /* Continue with existing CSS styles from your code... */
        body {
            background-color: var(--bg-color);
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(0, 247, 255, 0.15), transparent 40%),
                radial-gradient(circle at 80% 20%, rgba(255, 0, 255, 0.1), transparent 40%),
                linear-gradient(45deg, rgba(10, 14, 23, 0.9), rgba(20, 25, 40, 0.9));
            color: var(--text); 
            font-family: var(--font-main); 
            margin: 0; 
            padding: 0;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* ... ALL YOUR EXISTING CSS REMAINS THE SAME ... */
        /* I'm including a condensed version below but keeping all your original styles */

        .app-container {
            max-width: 100%;
            margin: 0 auto;
            padding: 15px;
            position: relative;
        }

        .cyber-header {
            text-align: center;
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(10, 15, 30, 0.8);
            border-radius: var(--radius);
            border: 1px solid var(--glass-border);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        /* ... Continue with all your existing CSS ... */

        /* HIDE FLOATING ICONS ON PREMIUM WALL */
        .premium-wall .floating-icons {
            display: none;
        }

        /* HIDE GAME WHEN NOT PREMIUM */
        .game-section-hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Premium Wall (Shows First) -->
    <div id="premiumWall" class="premium-wall">
        <div class="premium-container">
            <div class="premium-header">
                <h2>üîí STANY MINES PREMIUM</h2>
                <p>Access premium mines predictor features</p>
            </div>

            <div id="errorMessage" class="error-message" style="display: none;"></div>
            <div id="successMessage" class="success-message" style="display: none;"></div>

            <!-- Option 1: Enter Premium Code -->
            <div class="premium-card">
                <h3><i class="fas fa-key"></i> ENTER PREMIUM CODE</h3>
                <p>Already have a premium code? Enter it below:</p>
                
                <div class="code-input-container">
                    <div class="code-input">
                        <input type="text" id="premiumCodeInput" placeholder="ENTER CODE (e.g., PREMIUM2024)" maxlength="15">
                        <button class="validate-btn" onclick="validatePremiumCode()">
                            VALIDATE
                        </button>
                    </div>
                </div>
            </div>

            <!-- Option 2: Purchase Premium -->
            <div class="premium-card">
                <h3><i class="fas fa-bolt"></i> PURCHASE PREMIUM ACCESS</h3>
                <div class="premium-price">TZS 3,000</div>
                <ul class="premium-features">
                    <li><i class="fas fa-check"></i> Full access to predictor</li>
                    <li><i class="fas fa-check"></i> Live signals 24/7</li>
                    <li><i class="fas fa-check"></i> High accuracy predictions</li>
                    <li><i class="fas fa-check"></i> Premium support</li>
                    <li><i class="fas fa-check"></i> 30 days access</li>
                </ul>

                <div class="payment-section">
                    <p>Enter your phone number for payment:</p>
                    <div class="payment-phone-input">
                        <input type="tel" id="paymentPhone" placeholder="0712345678" maxlength="10">
                        <button class="pay-btn" onclick="initiatePayment()">
                            <i class="fas fa-lock"></i> PAY NOW
                        </button>
                    </div>
                    <p style="font-size: 12px; color: var(--text-muted);">
                        You will receive a USSD prompt on your phone
                    </p>
                </div>
            </div>

            <!-- Option 3: Reseller Codes -->
            <div class="premium-card">
                <h3><i class="fas fa-crown"></i> RESELLER ACCESS</h3>
                <p>For resellers with special codes:</p>
                <div class="code-input-container">
                    <div class="code-input">
                        <input type="text" id="resellerCodeInput" placeholder="RESELLER CODE" maxlength="20">
                        <button class="validate-btn" onclick="validateResellerCode()">
                            ACTIVATE
                        </button>
                    </div>
                </div>
                <p style="font-size: 12px; color: var(--text-muted); margin-top: 10px;">
                    Contact admin for reseller partnership
                </p>
            </div>

            <!-- User Status -->
            <div style="text-align: center; margin-top: 30px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                <p style="margin: 0; color: var(--text-muted);">
                    <i class="fas fa-user"></i> User ID: <span id="userIdDisplay">Loading...</span>
                </p>
            </div>
        </div>
    </div>

    <!-- Premium Status Bar (When Premium is Active) -->
    <div id="premiumStatusBar" class="premium-status-bar" style="display: none;">
        ‚≠ê PREMIUM ACTIVE | Expires: <span id="premiumExpiry">Loading...</span>
    </div>

    <!-- Main Game App (Hidden until Premium) -->
    <div id="gameApp" class="game-section-hidden">
        <!-- Your existing game HTML code starts here -->
        <div class="loading-overlay" id="loadingOverlay">
            <div class="cyber-loader"></div>
            <div class="loading-text" id="loadingText">ANALYZING PATTERNS</div>
        </div>

        <!-- Main App -->
        <div class="app-container">
            <!-- Cyber Header -->
            <div class="cyber-header">
                <h1 style="font-size: 1.5rem; margin-bottom: 5px;">STANY MINES</h1>
                <div style="font-family: var(--font-cyber); color: var(--neon-green); 
                            font-size: 0.9rem; letter-spacing: 1px; margin-top: 5px;">
                    PLAYER: <span id="playerName">VIP User</span>
                </div>
            </div>

            <!-- Bomb Selection -->
            <div class="cyber-section">
                <div class="section-title">BOMB CONFIGURATION</div>
                <div class="cyber-buttons" id="bombSelection">
                    <!-- Buttons will be generated by JavaScript -->
                </div>
            </div>

            <!-- Game Grid -->
            <div class="cyber-section game-grid-section">
                <div class="cyber-grid" id="gameGrid">
                    <!-- Grid cells will be generated by JavaScript -->
                </div>
            </div>

            <!-- Prediction Panel -->
            <div class="prediction-panel">
                <div class="prediction-content">
                    <div class="prediction-title">
                        <i class="fas fa-brain"></i> SERVER ANALYSIS 
                        <span class="recommendation-badge">üî¥live</span>
                    </div>
                    <div class="prediction-text" id="predictionDisplay">
                        <!-- Prediction text will be updated -->
                    </div>
                    
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="safeCount">?</div>
                            <div class="stat-label">SAFE CELLS</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="bombCount">2</div>
                            <div class="stat-label">BOMBS</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="accuracy">?</div>
                            <div class="stat-label">ACCURACY</div>
                        </div>
                    </div>
                </div>
            </div><br><br>

            <!-- Action Buttons -->
            <div class="action-panel">
                <button class="cyber-action-btn start-btn" id="startBtn">
                    <i class="fas fa-rocket"></i> START
                </button>
                <button class="cyber-action-btn reset-btn" id="resetBtn">
                    <i class="fas fa-sync-alt"></i> RESET
                </button>
            </div>
        </div>
        <!-- Your existing game HTML code ends here -->
    </div>

    <!-- Floating WhatsApp Icons (Only show in Game) -->
    <div class="floating-icons" style="display: none;" id="floatingIcons">
        <a href="#" id="whatsappSupport" target="_blank" class="floating-icon support">
            <i class="fab fa-whatsapp"></i>
            <div class="icon-tooltip">WhatsApp Support</div>
        </a>
        <a href="https://whatsapp.com/channel/0029Vb72cVkJ3jv10gzqTn18" target="_blank" class="floating-icon channel">
            <i class="fas fa-broadcast-tower"></i>
            <div class="icon-tooltip">Official Channel</div>
        </a>
    </div>

    <!-- Firebase Configuration -->
    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDtWAjmGIWVr3QGESAClBzRkQ5AZr5Zeys",
            authDomain: "stanybots.firebaseapp.com",
            projectId: "stanybots",
            storageBucket: "stanybots.firebasestorage.app",
            messagingSenderId: "381983533939",
            appId: "1:381983533939:web:201157399592c6389df306",
            measurementId: "G-W3C0C280BY"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
    </script>

    <script>
        // ===========================
        // PREMIUM SYSTEM
        // ===========================
        
        let currentUser = null;
        let userPremiumData = null;
        let whatsappNumber = "+255712345678"; // Default, will be updated from admin
        let channelLink = "https://whatsapp.com/channel/0029Vb72cVkJ3jv10gzqTn18";

        // Initialize the app
        async function initApp() {
            try {
                // Check if user is already logged in
                auth.onAuthStateChanged(async (user) => {
                    if (user) {
                        currentUser = user;
                        document.getElementById('userIdDisplay').textContent = user.uid.substring(0, 8) + '...';
                        
                        // Check premium status
                        await checkPremiumStatus();
                        
                        // Load admin settings (WhatsApp number, channel link)
                        await loadAdminSettings();
                    } else {
                        // Create anonymous user if not logged in
                        await auth.signInAnonymously();
                    }
                });
            } catch (error) {
                console.error("Initialization error:", error);
                showError("System initialization failed. Please refresh.");
            }
        }

        // Check user's premium status
        async function checkPremiumStatus() {
            if (!currentUser) return;

            try {
                const userDoc = await db.collection('users_premium')
                    .doc(currentUser.uid)
                    .get();

                if (userDoc.exists) {
                    const data = userDoc.data();
                    const now = new Date();
                    const expiresAt = data.expires_at.toDate();

                    if (data.is_active && expiresAt > now) {
                        // User has active premium
                        userPremiumData = data;
                        activatePremium();
                        return;
                    } else {
                        // Premium expired
                        await db.collection('users_premium').doc(currentUser.uid).update({
                            is_active: false
                        });
                    }
                }

                // No premium or expired
                userPremiumData = null;
                showPremiumWall();
            } catch (error) {
                console.error("Premium check error:", error);
                showError("Error checking premium status");
            }
        }

        // Activate premium access
        function activatePremium() {
            // Hide premium wall
            document.getElementById('premiumWall').style.display = 'none';
            
            // Show premium status bar
            document.getElementById('premiumStatusBar').style.display = 'block';
            
            // Update expiry display
            if (userPremiumData && userPremiumData.expires_at) {
                const expiryDate = userPremiumData.expires_at.toDate();
                const formattedDate = expiryDate.toLocaleDateString('en-US', {
                    day: 'numeric',
                    month: 'short',
                    year: 'numeric'
                });
                document.getElementById('premiumExpiry').textContent = formattedDate;
            }
            
            // Show game app
            document.getElementById('gameApp').classList.remove('game-section-hidden');
            
            // Show floating icons
            document.getElementById('floatingIcons').style.display = 'flex';
            
            // Initialize the game
            initGame();
        }

        // Show premium wall
        function showPremiumWall() {
            document.getElementById('premiumWall').style.display = 'flex';
            document.getElementById('gameApp').classList.add('game-section-hidden');
            document.getElementById('premiumStatusBar').style.display = 'none';
            document.getElementById('floatingIcons').style.display = 'none';
        }

        // Validate premium code
        async function validatePremiumCode() {
            const codeInput = document.getElementById('premiumCodeInput');
            const code = codeInput.value.trim().toUpperCase();

            if (!code) {
                showError("Please enter a premium code");
                return;
            }

            showLoading(true, "Validating code...");

            try {
                // Check if code exists
                const codeDoc = await db.collection('premium_codes')
                    .doc(code)
                    .get();

                if (!codeDoc.exists) {
                    showError("Invalid premium code");
                    showLoading(false);
                    return;
                }

                const codeData = codeDoc.data();

                // Validate code
                if (!codeData.is_active) {
                    showError("This code has expired");
                    showLoading(false);
                    return;
                }

                if (codeData.used_count >= codeData.max_uses) {
                    showError("This code has been used already");
                    showLoading(false);
                    return;
                }

                // Check expiry date
                const now = new Date();
                if (codeData.expires_at && codeData.expires_at.toDate() < now) {
                    showError("This code has expired");
                    showLoading(false);
                    return;
                }

                // Check if user already has premium
                const existingPremium = await db.collection('users_premium')
                    .doc(currentUser.uid)
                    .get();

                if (existingPremium.exists && existingPremium.data().is_active) {
                    showError("You already have active premium");
                    showLoading(false);
                    return;
                }

                // Activate premium for user
                const expiryDate = new Date();
                expiryDate.setDate(expiryDate.getDate() + codeData.duration_days);

                const batch = db.batch();

                // Update code usage
                const codeRef = db.collection('premium_codes').doc(code);
                batch.update(codeRef, {
                    used_count: firebase.firestore.FieldValue.increment(1),
                    last_used_at: new Date(),
                    last_used_by: currentUser.uid,
                    is_active: codeData.used_count + 1 < codeData.max_uses
                });

                // Create user premium record
                const userPremiumRef = db.collection('users_premium').doc(currentUser.uid);
                batch.set(userPremiumRef, {
                    user_id: currentUser.uid,
                    premium_code: code,
                    is_active: true,
                    activated_at: new Date(),
                    expires_at: expiryDate,
                    payment_status: 'code_activated',
                    code_type: codeData.type,
                    duration_days: codeData.duration_days,
                    price: codeData.price || 0
                });

                await batch.commit();

                // Update local data
                userPremiumData = {
                    is_active: true,
                    expires_at: { toDate: () => expiryDate }
                };

                showSuccess("Premium activated successfully!");
                showLoading(false);
                
                // Activate premium after 2 seconds
                setTimeout(() => {
                    activatePremium();
                }, 2000);

            } catch (error) {
                console.error("Code validation error:", error);
                showError("Error validating code. Please try again.");
                showLoading(false);
            }
        }

        // Validate reseller code
        async function validateResellerCode() {
            const codeInput = document.getElementById('resellerCodeInput');
            const code = codeInput.value.trim().toUpperCase();

            if (!code) {
                showError("Please enter reseller code");
                return;
            }

            showLoading(true, "Activating reseller code...");

            try {
                // Check if code exists and is reseller type
                const codeDoc = await db.collection('premium_codes')
                    .doc(code)
                    .get();

                if (!codeDoc.exists) {
                    showError("Invalid reseller code");
                    showLoading(false);
                    return;
                }

                const codeData = codeDoc.data();

                if (codeData.type !== 'reseller') {
                    showError("Not a reseller code");
                    showLoading(false);
                    return;
                }

                // Check if code is assigned to a reseller
                if (!codeData.reseller_id) {
                    showError("This code is not assigned to any reseller");
                    showLoading(false);
                    return;
                }

                // Check if code is active
                if (!codeData.is_active) {
                    showError("This reseller code has expired");
                    showLoading(false);
                    return;
                }

                // Check max uses
                if (codeData.used_count >= codeData.max_uses) {
                    showError("This reseller code has reached maximum uses");
                    showLoading(false);
                    return;
                }

                // Check if user already has premium
                const existingPremium = await db.collection('users_premium')
                    .doc(currentUser.uid)
                    .get();

                if (existingPremium.exists && existingPremium.data().is_active) {
                    showError("You already have active premium");
                    showLoading(false);
                    return;
                }

                // Activate premium for user (reseller codes usually have longer duration)
                const expiryDate = new Date();
                const durationDays = codeData.duration_days || 90; // Default 90 days for resellers
                expiryDate.setDate(expiryDate.getDate() + durationDays);

                const batch = db.batch();

                // Update code usage
                const codeRef = db.collection('premium_codes').doc(code);
                batch.update(codeRef, {
                    used_count: firebase.firestore.FieldValue.increment(1),
                    last_used_at: new Date(),
                    last_used_by: currentUser.uid,
                    is_active: codeData.used_count + 1 < codeData.max_uses
                });

                // Create user premium record
                const userPremiumRef = db.collection('users_premium').doc(currentUser.uid);
                batch.set(userPremiumRef, {
                    user_id: currentUser.uid,
                    premium_code: code,
                    is_active: true,
                    activated_at: new Date(),
                    expires_at: expiryDate,
                    payment_status: 'reseller_code',
                    code_type: 'reseller',
                    duration_days: durationDays,
                    reseller_id: codeData.reseller_id,
                    price: codeData.price || 0
                });

                await batch.commit();

                // Update local data
                userPremiumData = {
                    is_active: true,
                    expires_at: { toDate: () => expiryDate }
                };

                showSuccess("Reseller premium activated!");
                showLoading(false);
                
                // Activate premium after 2 seconds
                setTimeout(() => {
                    activatePremium();
                }, 2000);

            } catch (error) {
                console.error("Reseller code error:", error);
                showError("Error activating reseller code");
                showLoading(false);
            }
        }

        // HarakaPay Payment Integration
        async function initiatePayment() {
            const phoneInput = document.getElementById('paymentPhone');
            const phone = phoneInput.value.trim();

            if (!phone || phone.length !== 10 || !phone.startsWith('07')) {
                showError("Please enter a valid phone number (0712345678)");
                return;
            }

            showLoading(true, "Initiating payment...");

            try {
                // HarakaPay API call
                const response = await fetch('https://harakapay.net/api/v1/collect', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': 'hpk_fb763cc04e2feec29eb19041f75f54d0e6eb0067486caaae'
                    },
                    body: JSON.stringify({
                        phone: phone,
                        amount: 3000,
                        description: "Premium Mines Predictor Access"
                    })
                });

                const data = await response.json();

                if (!data.success) {
                    showError("Payment initiation failed: " + (data.message || "Unknown error"));
                    showLoading(false);
                    return;
                }

                // Save transaction to Firebase
                await db.collection('transactions').add({
                    user_id: currentUser.uid,
                    order_id: data.order_id,
                    phone: phone,
                    amount: data.amount,
                    net_amount: data.net_amount,
                    fee: data.fee,
                    status: 'pending',
                    type: 'premium_purchase',
                    created_at: new Date()
                });

                showSuccess("Payment request sent! Check your phone for USSD prompt.");
                showLoading(false);

                // Start polling for payment status
                pollPaymentStatus(data.order_id, phone);

            } catch (error) {
                console.error("Payment error:", error);
                showError("Payment failed. Please try again.");
                showLoading(false);
            }
        }

        // Poll payment status
        async function pollPaymentStatus(orderId, phone) {
            let attempts = 0;
            const maxAttempts = 60; // Poll for 5 minutes (5 seconds √ó 60 = 300 seconds)

            const pollInterval = setInterval(async () => {
                attempts++;
                
                if (attempts > maxAttempts) {
                    clearInterval(pollInterval);
                    showError("Payment timeout. Please try again.");
                    return;
                }

                try {
                    const response = await fetch(`https://harakapay.net/api/v1/status/${orderId}`, {
                        headers: {
                            'X-API-Key': 'hpk_fb763cc04e2feec29eb19041f75f54d0e6eb0067486caaae'
                        }
                    });

                    const data = await response.json();

                    if (data.success && data.payment.status === 'completed') {
                        clearInterval(pollInterval);
                        
                        // Update transaction status
                        const transactions = await db.collection('transactions')
                            .where('order_id', '==', orderId)
                            .get();
                        
                        if (!transactions.empty) {
                            const transactionId = transactions.docs[0].id;
                            await db.collection('transactions').doc(transactionId).update({
                                status: 'completed',
                                completed_at: new Date(),
                                payment_data: data
                            });
                        }

                        // Generate and activate premium code
                        await activatePremiumAfterPayment(phone);
                        
                    } else if (data.success && data.payment.status === 'failed') {
                        clearInterval(pollInterval);
                        showError("Payment failed. Please try again.");
                    }
                } catch (error) {
                    console.error("Polling error:", error);
                }
            }, 5000); // Poll every 5 seconds
        }

        // Activate premium after successful payment
        async function activatePremiumAfterPayment(phone) {
            showLoading(true, "Activating premium...");

            try {
                // Generate premium code
                const premiumCode = `PREMIUM${Date.now()}${Math.random().toString(36).substr(2, 5)}`.toUpperCase();

                const expiryDate = new Date();
                expiryDate.setDate(expiryDate.getDate() + 30); // 30 days premium

                const batch = db.batch();

                // Create premium code
                const codeRef = db.collection('premium_codes').doc(premiumCode);
                batch.set(codeRef, {
                    code: premiumCode,
                    type: "single_use",
                    max_uses: 1,
                    used_count: 0,
                    is_active: true,
                    price: 3000,
                    duration_days: 30,
                    created_at: new Date(),
                    expires_at: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // Expire in 1 year
                    created_by: "system_payment"
                });

                // Create user premium record
                const userPremiumRef = db.collection('users_premium').doc(currentUser.uid);
                batch.set(userPremiumRef, {
                    user_id: currentUser.uid,
                    premium_code: premiumCode,
                    is_active: true,
                    activated_at: new Date(),
                    expires_at: expiryDate,
                    payment_status: 'paid',
                    phone: phone,
                    amount: 3000,
                    activated_via: 'payment'
                });

                await batch.commit();

                // Update local data
                userPremiumData = {
                    is_active: true,
                    expires_at: { toDate: () => expiryDate }
                };

                showSuccess("Payment successful! Premium activated.");
                showLoading(false);
                
                // Activate premium after 3 seconds
                setTimeout(() => {
                    activatePremium();
                }, 3000);

            } catch (error) {
                console.error("Premium activation error:", error);
                showError("Error activating premium. Please contact support.");
                showLoading(false);
            }
        }

        // Load admin settings (WhatsApp number and channel link)
        async function loadAdminSettings() {
            try {
                const settingsDoc = await db.collection('admin_settings')
                    .doc('config')
                    .get();

                if (settingsDoc.exists) {
                    const settings = settingsDoc.data();
                    whatsappNumber = settings.whatsapp_number || whatsappNumber;
                    channelLink = settings.channel_link || channelLink;

                    // Update WhatsApp link
                    const whatsappLink = `https://wa.me/${whatsappNumber.replace('+', '')}`;
                    document.getElementById('whatsappSupport').href = whatsappLink;
                    document.getElementById('whatsappSupport').setAttribute('title', `Chat on WhatsApp: ${whatsappNumber}`);
                }
            } catch (error) {
                console.error("Error loading admin settings:", error);
            }
        }

        // UI Helper Functions
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            
            // Hide success message if shown
            document.getElementById('successMessage').style.display = 'none';
            
            // Auto hide after 5 seconds
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        function showSuccess(message) {
            const successDiv = document.getElementById('successMessage');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            
            // Hide error message if shown
            document.getElementById('errorMessage').style.display = 'none';
            
            // Auto hide after 5 seconds
            setTimeout(() => {
                successDiv.style.display = 'none';
            }, 5000);
        }

        function showLoading(show, text = "Loading...") {
            if (show) {
                document.getElementById('loadingText').textContent = text;
                document.getElementById('loadingOverlay').classList.add('active');
            } else {
                document.getElementById('loadingOverlay').classList.remove('active');
            }
        }

        // Initialize app when page loads
        window.addEventListener('DOMContentLoaded', initApp);
    </script>

    <!-- Your existing game JavaScript code -->
    <script>
        // ===========================
        // EXISTING GAME CODE
        // ===========================
        
        //JINA
        const PLAYER_NAME = "VIP User"; 

        // === GAME STATE ===
        const gameState = {
            active: false,
            bombs: 2,
            mines: [],
            safeCells: [],
            revealed: [],
            gridSize: 25,
            bombOptions: [2, 3, 5, 7],
            recommendations: [],
            bestChoices: []
        };
        
        // === SAVE/LOAD GAME STATE ===
        const STORAGE_KEY = "mines_predictor_save";

        function saveGameState() {
            const saveData = {
                active: gameState.active,
                bombs: gameState.bombs,
                mines: gameState.mines,
                revealed: gameState.revealed,
                recommendations: gameState.recommendations,
                bestChoices: gameState.bestChoices,
                savedAt: Date.now()
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(saveData));
        }

        function loadGameState() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return false;
            
            try {
                const data = JSON.parse(saved);
                
                // Check if save is not too old (1 hour max)
                if (Date.now() - data.savedAt > 3600000) {
                    localStorage.removeItem(STORAGE_KEY);
                    return false;
                }
                
                // Restore game state
                gameState.active = data.active;
                gameState.bombs = data.bombs;
                gameState.mines = data.mines || [];
                gameState.revealed = data.revealed || [];
                gameState.recommendations = data.recommendations || [];
                gameState.bestChoices = data.bestChoices || [];
                
                return true;
            } catch (e) {
                localStorage.removeItem(STORAGE_KEY);
                return false;
            }
        }

        function clearGameState() {
            localStorage.removeItem(STORAGE_KEY);
        }

        // === DOM ELEMENTS ===
        let bombSelection, gameGrid, predictionDisplay, startBtn, resetBtn, loadingOverlay, loadingText, safeCount, bombCount, accuracy;

        // === INITIALIZATION ===
        function initGame() {
            // Get DOM elements
            bombSelection = document.getElementById('bombSelection');
            gameGrid = document.getElementById('gameGrid');
            predictionDisplay = document.getElementById('predictionDisplay');
            startBtn = document.getElementById('startBtn');
            resetBtn = document.getElementById('resetBtn');
            loadingOverlay = document.getElementById('loadingOverlay');
            loadingText = document.getElementById('loadingText');
            safeCount = document.getElementById('safeCount');
            bombCount = document.getElementById('bombCount');
            accuracy = document.getElementById('accuracy');
            
            // Set player name
            document.getElementById('playerName').textContent = PLAYER_NAME;
            
            // Try to load saved game
            const hasSavedGame = loadGameState();
            
            renderBombSelection();
            renderGrid();
            setupEventListeners();
            
            // Initialize stats with "?" (unknown)
            safeCount.textContent = "?";
            bombCount.textContent = gameState.bombs;
            accuracy.textContent = "?";
            
            if (hasSavedGame && gameState.active) {
                // Restore the game display
                updateGameGrid();
                updateStats();
                updatePrediction("GAME RESTORED - CONTINUING...");
                showNotification("Game restored", "info");
            } else {
                // Show initial message with time
                const currentTime = getFormattedTime();
                updatePrediction(`SELECT BOMB COUNT AND START<br>
                Current time: <span class="cyber-highlight">${currentTime}</span>`);
            }
        }

        // === TIME FUNCTION ===
        function getFormattedTime() {
            const now = new Date();
            let hours = now.getHours();
            let minutes = now.getMinutes();
            const ampm = hours >= 12 ? 'PM' : 'AM';
            
            hours = hours % 12;
            hours = hours ? hours : 12;
            minutes = minutes < 10 ? '0' + minutes : minutes;
            
            return `${hours}:${minutes} ${ampm}`;
        }

        // === RENDER FUNCTIONS ===
        function renderBombSelection() {
            bombSelection.innerHTML = '';
            gameState.bombOptions.forEach(bombCount => {
                const btn = document.createElement('button');
                btn.className = 'cyber-btn';
                
                if (bombCount === 2 || bombCount === 3) {
                    btn.classList.add('safe-bomb');
                } else if (bombCount >= 5) {
                    btn.classList.add('high-risk');
                }
                
                if (bombCount >= 5) {
                    btn.classList.add('high-risk-btn');
                }
                
                if (bombCount === gameState.bombs) {
                    btn.classList.add('selected');
                }
                
                btn.textContent = bombCount;
                btn.onclick = () => selectBombs(bombCount);
                bombSelection.appendChild(btn);
            });
        }

        function renderGrid() {
            gameGrid.innerHTML = '';
            for (let i = 0; i < gameState.gridSize; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.index = i;
                cell.textContent = '?';
                gameGrid.appendChild(cell);
            }
        }

        // === GAME LOGIC ===
        function selectBombs(count) {
            gameState.bombs = count;
            renderBombSelection();
            
            bombCount.textContent = count;
            safeCount.textContent = "?";
            accuracy.textContent = "?";
            
            const currentTime = getFormattedTime();
            
            if (count >= 5) {
                updatePrediction(`‚ö†Ô∏è <span class="danger-highlight">HIGH RISK WARNING!</span> ‚ö†Ô∏è<br>
                ${count} BOMBS DETECTED - DANGER!<br>
                Survival probability: <span class="danger-highlight">${Math.round((25-count)/25*100)}%</span><br>
                Current time: <span class="cyber-highlight">${currentTime}</span><br>
                <span class="cyber-highlight">Advice: Choose lower bomb (2-3) for better odds</span>`);
            } else {
                updatePrediction(`BOMBS SET TO: ${count}. READY FOR ANALYSIS.<br>
                Current time: <span class="cyber-highlight">${currentTime}</span>`);
            }
        }

        async function startGame() {
            if (gameState.active) {
                showNotification("ANALYSIS ALREADY IN PROGRESS", "warning");
                return;
            }

            showLoading(true);
            loadingText.textContent = "GENERATING MINEFIELD";
            
            safeCount.innerHTML = '<span style="color: var(--neon-pink); animation: pulse 1.5s infinite;">loading...</span>';
            bombCount.textContent = gameState.bombs;
            accuracy.innerHTML = '<span style="color: var(--neon-pink); animation: pulse 1.5s infinite;">loading...</span>';
            
            await sleep(800);

            gameState.active = true;
            gameState.mines = [];
            gameState.safeCells = [];
            gameState.revealed = [];
            gameState.recommendations = [];
            gameState.bestChoices = [];

            const positions = Array.from({length: gameState.gridSize}, (_, i) => i);
            for (let i = 0; i < gameState.bombs; i++) {
                const randomIndex = Math.floor(Math.random() * positions.length);
                gameState.mines.push(positions[randomIndex]);
                positions.splice(randomIndex, 1);
            }

            loadingText.textContent = "ANALYZING PATTERNS";
            await sleep(800);

            const totalSafe = gameState.gridSize - gameState.bombs;
            const cellsToReveal = Math.floor(totalSafe * (0.4 + Math.random() * 0.2));
            
            for (let i = 0; i < cellsToReveal; i++) {
                const safePositions = positions.filter(p => !gameState.mines.includes(p));
                if (safePositions.length === 0) break;
                
                const randomIndex = Math.floor(Math.random() * safePositions.length);
                const safeCell = safePositions[randomIndex];
                gameState.revealed.push(safeCell);
                positions.splice(positions.indexOf(safeCell), 1);
            }

            loadingText.textContent = "CALCULATING PROBABILITIES";
            await sleep(800);
            calculateRecommendations();

            if (gameState.bombs >= 5) {
                gameState.recommendations = gameState.bestChoices.slice(0, 1);
            }

            loadingText.textContent = "RENDERING RESULTS";
            await sleep(600);
            showLoading(false);

            await animateGridReveal();
        }

        function resetGame() {
            gameState.active = false;
            gameState.mines = [];
            gameState.safeCells = [];
            gameState.revealed = [];
            gameState.recommendations = [];
            gameState.bestChoices = [];

            safeCount.textContent = "?";
            bombCount.textContent = gameState.bombs;
            accuracy.textContent = "?";
            
            document.querySelectorAll('.grid-cell').forEach((cell, index) => {
                cell.className = 'grid-cell';
                cell.textContent = '?';
                setTimeout(() => {
                    cell.style.opacity = '0.5';
                    setTimeout(() => {
                        cell.style.opacity = '1';
                    }, 100);
                }, index * 20);
            });

            const currentTime = getFormattedTime();
            updatePrediction(`SYSTEM RESET. SELECT BOMBS AND START ANALYSIS.<br>
            Current time: <span class="cyber-highlight">${currentTime}</span>`);
            showNotification("SYSTEM RESET", "info");
            clearGameState();
        }
        
        function updateGameGrid() {
            const cells = document.querySelectorAll('.grid-cell');
            
            cells.forEach((cell, index) => {
                cell.className = 'grid-cell';
                cell.textContent = '?';
                
                if (gameState.mines.includes(index)) {
                    cell.classList.add('mine', 'revealed');
                    cell.textContent = 'üí£';
                } else if (gameState.revealed.includes(index)) {
                    cell.classList.add('safe', 'revealed');
                    cell.textContent = 'üíé';
                }
                
                if (gameState.recommendations.includes(index)) {
                    cell.classList.add('recommended');
                }
                if (gameState.bestChoices.includes(index)) {
                    cell.classList.add('best-choice');
                }
                
                if (!gameState.mines.includes(index)) {
                    cell.classList.add('safe');
                }
            });
        }

        function calculateRecommendations() {
            const allCells = Array.from({length: gameState.gridSize}, (_, i) => i);
            const unrevealedSafe = allCells.filter(i => 
                !gameState.mines.includes(i) && 
                !gameState.revealed.includes(i)
            );

            const scores = unrevealedSafe.map(index => {
                const neighbors = getNeighbors(index);
                const mineNeighbors = neighbors.filter(n => gameState.mines.includes(n));
                const safeNeighbors = neighbors.filter(n => 
                    !gameState.mines.includes(n) && gameState.revealed.includes(n)
                );
                
                let score = 100;
                score -= mineNeighbors.length * 30;
                score += safeNeighbors.length * 15;
                
                const row = Math.floor(index / 5);
                const col = index % 5;
                if ((row === 0 || row === 4) && (col === 0 || col === 4)) {
                    score += 10;
                }
                
                return { index, score };
            });

            scores.sort((a, b) => b.score - a.score);

            const numRecommendations = Math.min(3, scores.length);
            gameState.recommendations = scores.slice(0, numRecommendations).map(s => s.index);

            if (scores.length > 0) {
                gameState.bestChoices = [scores[0].index];
            }
        }

        function getNeighbors(index) {
            const neighbors = [];
            const row = Math.floor(index / 5);
            const col = index % 5;
            
            for (let r = row - 1; r <= row + 1; r++) {
                for (let c = col - 1; c <= col + 1; c++) {
                    if (r >= 0 && r < 5 && c >= 0 && c < 5 && !(r === row && c === col)) {
                        neighbors.push(r * 5 + c);
                    }
                }
            }
            return neighbors;
        }

        async function animateGridReveal() {
            const cells = document.querySelectorAll('.grid-cell');
            
            for (let i = 0; i < cells.length; i++) {
                cells[i].classList.add('loading');
                cells[i].style.animationDelay = `${i * 0.05}s`;
            }
            
            await sleep(1500);

            for (let i = 0; i < cells.length; i++) {
                const cell = cells[i];
                cell.classList.remove('loading');
                
                if (gameState.mines.includes(i)) {
                    cell.classList.add('mine', 'revealed');
                    cell.textContent = 'üí£';
                } else {
                    cell.classList.add('safe', 'revealed');
                    cell.textContent = 'üíé';
                }
                
                if (gameState.recommendations.includes(i)) {
                    cell.classList.add('recommended');
                }
                if (gameState.bestChoices.includes(i)) {
                    cell.classList.add('best-choice');
                }

                if (!gameState.mines.includes(i)) {
                    cell.classList.add('safe');
                }

                cell.style.animationDelay = `${i * 0.1}s`;
                cell.classList.add('revealed');
                
                await sleep(50);
            }

            updateStats();
            showNotification("ANALYSIS COMPLETE", "success");
            saveGameState();

            updatePredictionDisplay();
        }

        function updatePrediction(message) {
            const predictionText = message
                .replace(/SAFE/gi, '<span class="cyber-highlight">$&</span>')
                .replace(/BOMB/gi, '<span class="danger-highlight">$&</span>')
                .replace(/\d+/g, '<span class="cyber-highlight">$&</span>');
            
            predictionDisplay.innerHTML = predictionText;
        }

        function updatePredictionDisplay() {
            if (gameState.recommendations.length > 0) {
                const recNumbers = gameState.recommendations.map(i => i + 1);
                const bestChoice = gameState.bestChoices[0] + 1;
                
                const currentTime = getFormattedTime();
                
                let prediction = `SCANING <span class="cyber-highlight">COMPLETED</span> THESE ARE YOUR <span class="cyber-highlight">SAFE</span> PICKS FOR THIS ROUND üü¢<br><br>`;
                
                prediction += `<span style="color: var(--neon-blue); font-size: 0.9rem;">
                    ‚è∞ PREDICTION TIME: <span class="cyber-highlight">${currentTime}</span>
                </span><br>`;
                
                if (gameState.bombs >= 5) {
                    prediction += `<span class="danger-highlight">‚ö†Ô∏è HIGH RISK GAME ‚ö†Ô∏è</span><br>`;
                    prediction += `With ${gameState.bombs} bombs, survival chance: <span class="danger-highlight">${Math.round((25-gameState.bombs)/25*100)}%</span><br><br>`;
                    prediction += `<span class="cyber-highlight">SAFEST SINGLE CELL: ${recNumbers[0]}</span><br>`;
                    prediction += `Advice: <span class="danger-highlight">Play only 2 rounds</span>`;
                } else {
                    prediction += `TOP RECOMMENDATIONS: <span class="cyber-highlight">${recNumbers.join(', ')}</span><br>`;
                    prediction += `BEST CHOICE: <span class="cyber-highlight">${bestChoice}</span> (LOWEST RISK)<br><br>`;
                    prediction += `<span class="danger-highlight">${gameState.mines.length} BOMBS</span> DETECTED IN GRID`;
                }
                
                predictionDisplay.innerHTML = prediction;
            } else {
                updatePrediction("ANALYSIS IN PROGRESS...");
            }
        }

        function updateStats() {
            safeCount.textContent = gameState.gridSize - gameState.bombs;
            bombCount.textContent = gameState.bombs;
            
            const randomAccuracy = 95 + Math.floor(Math.random() * 6);
            accuracy.textContent = `${randomAccuracy}%`;
        }

        function showNotification(message, type = "info") {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: ${type === 'success' ? 'var(--neon-green)' : 
                           type === 'warning' ? 'var(--neon-yellow)' : 
                           type === 'danger' ? 'var(--neon-red)' : 'var(--neon-blue)'};
                color: #000;
                padding: 12px 25px;
                border-radius: 30px;
                font-family: var(--font-cyber);
                font-weight: 700;
                opacity: 0;
                pointer-events: none;
                transition: all 0.3s;
                z-index: 2000;
                text-align: center;
                box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.top = '20px';
            }, 10);

            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.top = '-50px';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 2000);
        }

        // === UTILITY FUNCTIONS ===
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function setupEventListeners() {
            if (startBtn) startBtn.onclick = startGame;
            if (resetBtn) resetBtn.onclick = resetGame;
        }
        
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && gameState.active) {
                saveGameState();
            }
        });

        window.addEventListener('beforeunload', function() {
            if (gameState.active) {
                saveGameState();
            }
        });
    </script>
</body>
</html>
